# 14.26 - Refining the Class Design Model

<img src="/images/14_26_01.jpg" width="800" height="500">
<img src="/images/14_26_02.jpg" width="800" height="500">
<img src="/images/14_26_03.jpg" width="800" height="500">
<img src="/images/14_26_04.jpg" width="800" height="500">
<img src="/images/14_26_05.jpg" width="800" height="500">
<img src="/images/14_26_06.jpg" width="800" height="500">

**After looking at refining the class design model where we refined attributes of the domain model, we refined the class relationships, we refined methods and constructors and, of course, we reviewed the coupling and coherency of our model. Let's go ahead and look at an example that actually describes some of the features and concepts that we learnt in this particular module. Well, the current slides that we have here is related to the hotel reservation system and again we have seen these type of classes in one of the previous examples, but in this case what we are doing is we refining the attributes and we are also elaborating the business methods, declaring constructors, and annotating methods and constructors. So again we recognize room and we see now that we encapsulated the attribute roomId and status to be private and, of course, now we know the type. The roomId type is RoomId and the status is of type RoomStatus. We also have the methods here that addReservation() that takes a reservation and returns void, getReservations() returns the list of reservations, removeReservation that takes a reservation and returns the RoomId that actually was released all the room that was released and then we have the constructor in this case room it has the same name as the class and it takes in this case the RoomId and the RoomType and, of course, the constructor typically does not return anything. And we have setRoomId, which takes a roomId, and sets the RoomId. Again will see that the room has room types and the same thing with room type we specify the description as a string and we also have the addRoom, deleteRoom, and findRooms, again, with their particular signatures. Again we look at Customer class that has, again, in this case, a bunch of attributes, Address, firstName, lastName, phoneNumber, and we specify their type and, of course, the methods also we specify the signatures. In addition, we have actually a constructor of this class which is the Customer and it takes an entire string representing, again, the firstName is string and the lastName and an address that represents the Address. And we have a second constructor that takes in this case, couple of strings and address and a phoneNumber. Again in this case we are overloading the constructor of the Customer class and we have the get lastName method which returns a string. Looking at the Reservation class, we also see some of the types of the attributes and we also see some of the method as method signatures that we see plus in addition we actually have a constructor for this class. Again the constructor is reservation that takes a date and a list of again room types and we have a bunch of methods like addRoom, changeRoom, checkedIn(), confirmed(), getDatesOfStay(), getPaymentGuarantee(), and so forth. Again all of these are specified with their signature or signatures. The PaymentGuarantee, again, we see the class with the attribute amount of type Money and also we see the couple of methods getAmount( ) and setAmount with their signatures. We have the also the from this PaymentGuarantee, we extend two classes, the Card PaymentGuarantee and the PurchaseOrderGuarantee and you have seen that earlier except that this time, we specify the attribute types for these classes and, of course, we have the methods with their respective signatures. We also see the company class and in this case it makes use of, it has a bunch of attributes that are set as private and, of course, we specify their types and the next again slide represents the rest of the classes. We have the Bill class, it has, again, a bunch of attributes and their types and, of course, a bunch of methods with their respective signatures. We also can see a constructor Bill that takes the InitialCharge, again, item in this case or a ChargeableItem and we have method canChargesBeAdded and deleteChargeableItem and getChargeableItems and getTotal and so forth. Again all of these are represented with their respective signatures. The ChargeableItemType class, again, the same thing has an attribute with its own type and also a bunch of methods, again, including a constructor in this case ChargeableItemType that takes a string in this case. And the last class that we see is the ChargeableItem class, again, that has a bunch of attributes with their types and, of course, the methods with their respective signatures. It also has a constructor ChargeableItem that takes an instance of Money, Date, ItemType, and ChargeableItemType.**