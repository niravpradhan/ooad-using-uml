# 2.3 - Software Complexity

<img src="/images/02_03_01.jpg" width="600" height="300">

**Let us look at Software Complexity. Well complex systems have a bunch of characteristics and they are the fact that they have a hierarchical structure. Again in procedural programming, a complex system is decomposed into a hierarchy of subroutines; again, this tends to be brittle. On the other hand in OO programming, a complex system is decomposed into a hierarchy of collaborating objects, this structure tend to be more flexible and extensible because you are recomposing different collaborations between existing objects to solve new problems. The choice of which components are primitive in the system is again of course arbitrary. The choice of what is primitive in a system depends on the prospective of the observer. So this principle provides the designer with the handle on system complexity by again shielding the complex details of one layer behind an abstraction on a higher level. A system can be split into intra- and inter-component relationships. Again, the separation of concerns enables you to study each part in relative isolation. So separation of concerns is an important principle in designing and building complex systems. Using this principle an object should focus its activity on one or few simple concerns. Again, the client of that object does not need to know how the object does its work. Complex systems are usually composed of only few types of components in various combinations. Again, like organic systems, software systems tend to have few fundamental types of components that are used to build the system. Again, in animal biology typically the structures include skin, bones, muscle, neurons, and so on. And in computer systems these, structures include user interface, control which is the workflow, and of course entity components which represent data. Well a successful complex systems invariably evolves from a simple working system. So successful complex systems tend to be grown rather than created. A complex system usually starts small with few domain objects and adds complexity by extending these domain objects and rearranging them in a new ways. For example, the web application for a company like Amazon.com started by selling books and then started selling CDs and videos and providing reader reviews, promotions, and so on.**

