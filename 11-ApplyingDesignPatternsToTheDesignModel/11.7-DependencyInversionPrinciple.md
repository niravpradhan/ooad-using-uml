# 11.7 - Dependency Inversion Principle

<img src="/images/11_07_01.jpg" width="800" height="500">
<img src="/images/11_07_02.jpg" width="800" height="500">

**Let's go ahead and look now on Dependency Inversion Principle. Well, for the Dependency Inversion Principle typically we say that it depend on abstractions and do not depend on concretions, so the Dependency Inversion Principle actually is now telling us that we should depend on abstractions and we should not depend on concretions. When again looking at the definition of this dependency inversion. CRP actually provides a glimpse of Dependency Inversion Principle. The point of the Dependency Inversion Principle is that if you need to delegate to another component then it is best to write the client code to an abstract class. Again the figure that we have seen rather on the previous page show an example of dependency inversion where the container class uses an object of the layout class hierarchy and the container class does not need to know which LayoutManager is used because the client of the container uses the setLayout method to specify the LayoutManager at runtime. So on this particular slide here we see an abstraction that can be an abstract class, in this case for example client makes use of a service which is abstract and that service can be either supplier 1 or supplier 2. So in this case we are making use of an abstract class, so in this case dependency inversion principle uses an abstract class. Now, looking at another example where the Dependency Inversion Principle actually uses in this case an interface, so we see how the client makes use of the service interface and that service interface can be implemented by supplier 1 or supplier 2.**