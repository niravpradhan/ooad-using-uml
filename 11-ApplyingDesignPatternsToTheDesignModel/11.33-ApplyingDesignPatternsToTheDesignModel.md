# 11.33 - Applying Design Patterns to the Design Model

<img src="/images/11_33_01.jpg" width="800" height="500">
<img src="/images/11_33_02.jpg" width="800" height="500">
<img src="/images/11_33_03.jpg" width="800" height="500">
<img src="/images/11_33_04.jpg" width="800" height="500">
<img src="/images/11_33_05.jpg" width="800" height="500">
<img src="/images/11_33_06.jpg" width="800" height="500">
<img src="/images/11_33_07.jpg" width="800" height="500">
<img src="/images/11_33_08.jpg" width="800" height="500">
<img src="/images/11_33_09.jpg" width="800" height="500">

**After looking at applying design patterns to the design model where we discussed the design patterns. We looked at the composite pattern. We looked at the strategy pattern. We looked at the observer pattern. We looked at the abstract factory pattern, and we looked at the state pattern. Letâ€™s go ahead and look at an example that illustrates some of the features that we learned in this module. And we start with the example of a strategy pattern. So, again in our case here we are talking about the hotel system case study. Well, in this case, we decided that the marketing department of the hotel will implement various discount offers that are used to calculate the quoted prize. Again, these offers may include two nights stay for a prize of one night provided it is a weekend that is Friday, Saturday, or Sunday. Five nights stay of the prize of four nights at anytime during the off period and 10% discount during the offer period. So again these discount offers will vary between the hotel properties. And again our job here is to ensure that the hotel system can accommodate algorithms for these different offers. And again we must also ensure that new offers with different algorithms can be easily added in the future. So the idea here is to design a class diagram that shows the strategy pattern solving this problem that we just discussed. And we see an example again a solution here where we have the hotel that has promotion again represented by the class promotion. We have the end date, start date, the voucherCode, and calculate discount where we pass the reservation. And of course, from it we made use of strategy and we can actually now extend that promotion class to either a FreeNightWeekendOnlyOffer or again a PercentageDiscountOffer class or a FreeNightAnyTimeOffer. So, again if you look at the FreeNightWeekendOnlyOffer, it actually overrides the calculate discount method of the promotion class. And the subclass PercentageDiscountoffer has an extra attribute called percentage discount and of course, overrides the calculate discount method. In the FreeNightAnyTimeOffer has actually couple of extra attributes which are the which are the numberOf NightsFree, And of course, numberOfNightsToQualify, and of course, it overrides the calculate discount method. Now, looking at again the next slide that we going to look at is the slide that actually talks about the observer pattern. Well, again the problem is related to the hotel system case study, but in this case we decided when a customer vacates a room after check-in out various individual members of the staff should be notified immediately and department display screens should be updated. Again, the individual staff members should be notified by a message sent to a portable handheld device. Again, these members of the staff should include a chambermaid, the housekeeping supervisor, the mini-bar stock list, and room maintenance. And of course, the departmental display screen should show the status of rooms in various departments including housekeeping and maintenance. And our job is to ensure that the hotel system includes the functionality to notify the concerned members of the staff and update the departmental display screens as soon as possible after the room becomes again vacant. And we must also ensure that when a room became vacant other notifications that we may be required in the future can actually be added easily. So again looking at the problem and we came up with a solution that makes use of the observer pattern to solve this problem. And we see the observable here class that has again the method attach, detach, and notify and from it we actually will go ahead and extend that observable to with the classroom, so again making use of inheritance while in this case room pretty much inherits from the observable class, so the room class inherits from the observable class and the room has additional. It has a couple of attribute roomId and status and of course, it has a method called a vacator. On the other hand on the observer part, we can see that the observer is an interface and it has the update method that needs to be implemented and in this particular slide we made the classes HandHeldDeviceNotification class to again implement.interface the observer interface by implementing the update method. And of course, we also have the status display class that implements the observer interface again by implementing the update method too. And again, we have a couple of notes over there where for the HandHeldDeviceNotification, the update method again in this case identified the roomId, send the message that includes roomId to handheld device. On the other hand for the update method that is in the StatusDisplay class that again implements the interface observer, we update method and here refreshes all rooms clinically on display. The next problem that we would like to solve is the one related to the state pattern. So let's assume that actually we have the pseudocode and we want to examine this pseudocode again this large block of code is currently used in the account object to ensure that it acts appropriately when a customer attempts to withdraw the money again this is related to a banking system that we have seen earlier. And if we take a look at these pseudocode here we see that withdraw method, and then we have a lot of if else, if has, so if account status is active go ahead allow the customer to withdraw upto whatever you know of draft limit plus current balance, else if the account status is overdrawn display message you are outdrawn and then allow customer to withdraw upto the object limit less current imbalance else if the account status is equal to frozen then in this case we displayed the message account frozen you cannot withdraw money, please visit the bank manager, else display the message account is closed you cannot withdraw money. So given that again we know about the state pattern, how do we actually resolve this issue or how do we refactor this code to actually make use of the of course, state patterns. So the idea is to create a class diagram that represents our refactoring based on the state pattern. Again, we should make sure to annotate every class in the diagram to show where the code goes and here is typically a solution for that, so we see how an account again can have different status and we have the status class here that has the deposit method, the withdraw method, and the transfer method and from the account status we can actually create now the account active class which is again here the withdrawal amount upto current balance plus the overdraft limit. We also have the account of withdrawing again it has, it implements deposit withdrawing transfer method and in the same thing in this case the display message withdraw for this particular account withdrawn class would be again the amount upto to the current balance plus the overdraft limit. We have the next class in this class that we graded this account frozen. And again need to various deposit withdrawn transfer and this displays the message that the account is frozen. And of course, we have the next class which is account closed and in this particular case again this account close has a deposit withdraw and transfer methods. So this actually shows us an example of class diagram that actually represents our refactoring based on the state pattern. And we have seen that this is a lot easier to work with compared to the pseudocode that we have seen which actually has a lot of if has, if has, if has and so forth.**