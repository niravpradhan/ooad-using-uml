# 11.11 - Describing the Composite Pattern (Contd.)

<img src="/images/11_11_01.jpg" width="800" height="500">

**Now, looking at the alternate model. So the reason why we actually define an alternate model is because if we look at the previous slide again this might seem confusing at first because leaf classes would not have meaningful implementation of the methods like for example add, remove, and getChild because the leaf cannot actually is the final component. We cannot add components to the leaf so however the solution provides the most flexibility for the client code because all sub classes of the component use the same interface, so one way to actually avoid using the add, remove, and getChild element methods from the leaf is to actually get to the slide which is the represents the alternate model. So the alternate model represents an alternate solution that puts the composite methods only in the composite class and the figure on this slide illustrates this and this is actually what we like, so in the sense that components like a leaf for example has the operations but then it is only the composite component that has the add, remove, and of course, getChild methods.**