# 11.6 - Composite Resuse Principle

<img src="/images/11_06_01.jpg" width="800" height="500">
<img src="/images/11_06_02.jpg" width="800" height="500">
<img src="/images/11_06_03.jpg" width="800" height="500">

**Let's look now at the Composite Reuse Principle or CRP. Well, for the Composite Reuse Principle we favor polymorphic composition of objects over inheritance. Again the point of this principle is that creating a new behavior by using inheritance is often not very flexible, so in the Graphical User Interface container example we might need a new type of container layout instead of a grid. Again you might want to layout a group of components in regions around the container screen, again you could create an abstract container super class with two sub-classes, GridContainer and BorderContainer. Again the figure that we see on this slide illustrates this. Well, there is nothing inherently wrong with this strategy, however the graphical user containers can actually have many different features, suppose that you want to actually be able to create a border around the group of Graphical User Interface components, again you could create a flat border which draws a line around the boundary of the Graphical User Interface components or you could draw an edged border around the components to give a 3D effect to the container and then conceptually you have two independent hierarchies of functionality one for container layout and one for drawing a border around the container on the screen, however you cannot have two hierarchies but rather a single hierarchy that is a cross product of the two features. Again the next figure or the next slide illustrates this where if you take a look you see that again we have a container and from it we have a GridContainer and a BorderContainer and we also have again the ContainerFlatBorder and the ContainerEtchedBorder and so here and from again the diagram below we see from the container we can have a GridContainerFlatBorder, GridContainerEtchedBorder, a BorderContainerFlatBorder, and a BorderContainerEtchedBorder. Again this is a brittle class structure. Suppose that we now needed a new border visualization, for example around the corner border, so we would have to create two additional classes, a GridContainer rounded border and a BorderContainer rounded border. If we have n types of layouts and m types of borders then we potentially must create n times m container classes and that's really bad. So again continuing with the problem now let's go ahead and look at and continuing and see how we can actually resolve this problem, so the CRP provides an alternative to this problem, however the Composite Reuse Principle provides an alternative to this problem. For every feature of the Graphical User Interface container, we could actually create a separate class hierarchy that supports only that particular feature, so the container class would then use an implementation of a class that supports that particular feature. For example, we could have a single container class that delegates the layout functionality to an independent object and the figure that we see on this slide actually illustrates that, so the Graphical User Interface border functionality can also be delegated by the container class, so this is not again shown in this previous diagram, but it does make sense to use the CRP to delegate this functionality to a separate object with the class hierarchy and dependent of the container class. So in this case for example we see how the container makes use of the layout and from the layout we can actually create either which is a layout in this case is an abstract class and from it we create a GridLayout or a BorderLayout.**